{"version":3,"file":"background/service-worker.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://wingdings-converter/./background/dictionary-manager.js","webpack://wingdings-converter/webpack/bootstrap","webpack://wingdings-converter/./background/service-worker.js"],"sourcesContent":["class DictionaryManager {\n  constructor() {\n    this.STORAGE_KEY = 'wingdings_dictionary';\n    this.MAX_ENTRIES = 5000;\n    this.MAX_STORAGE_SIZE = 95 * 1024; // 95KB (100KB制限の95%)\n    this.cache = new Map();\n  }\n\n  async init() {\n    const data = await chrome.storage.sync.get(this.STORAGE_KEY);\n    this.dictionary = data[this.STORAGE_KEY] || {\n      words: {},\n      settings: {\n        autoConvert: false,\n        showUnknownWords: true,\n        romajiStyle: 'hepburn'\n      },\n      metadata: {\n        version: '1.0',\n        lastUpdate: Date.now(),\n        entryCount: 0\n      }\n    };\n    \n    this.buildCache();\n  }\n\n  buildCache() {\n    this.cache.clear();\n    Object.entries(this.dictionary.words).forEach(([word, data]) => {\n      this.cache.set(word, data);\n    });\n  }\n\n  async addWord(kanji, reading, romaji = null) {\n    // 容量チェック\n    if (Object.keys(this.dictionary.words).length >= this.MAX_ENTRIES) {\n      throw new Error(`Dictionary limit reached: ${this.MAX_ENTRIES} words`);\n    }\n\n    // 自動ローマ字変換\n    if (!romaji) {\n      romaji = convertToRomaji(reading);\n    }\n\n    const wordData = {\n      reading: reading,\n      romaji: romaji,\n      frequency: 1,\n      lastUsed: Date.now(),\n      dateAdded: Date.now()\n    };\n\n    // 既存の単語は頻度更新\n    if (this.dictionary.words[kanji]) {\n      this.dictionary.words[kanji].frequency++;\n      this.dictionary.words[kanji].lastUsed = Date.now();\n    } else {\n      this.dictionary.words[kanji] = wordData;\n      this.dictionary.metadata.entryCount++;\n    }\n\n    this.dictionary.metadata.lastUpdate = Date.now();\n    this.cache.set(kanji, wordData);\n\n    await this.save();\n    return wordData;\n  }\n\n  async removeWord(kanji) {\n    if (this.dictionary.words[kanji]) {\n      delete this.dictionary.words[kanji];\n      this.cache.delete(kanji);\n      this.dictionary.metadata.entryCount--;\n      this.dictionary.metadata.lastUpdate = Date.now();\n      await this.save();\n      return true;\n    }\n    return false;\n  }\n\n  getWord(kanji) {\n    return this.cache.get(kanji) || null;\n  }\n\n  async searchWords(query, limit = 50) {\n    const results = [];\n    const queryLower = query.toLowerCase();\n\n    for (const [kanji, data] of this.cache.entries()) {\n      if (results.length >= limit) break;\n      \n      if (kanji.includes(query) || \n          data.reading.includes(query) || \n          data.romaji.toLowerCase().includes(queryLower)) {\n        results.push({\n          kanji: kanji,\n          ...data,\n          relevance: this.calculateRelevance(query, kanji, data)\n        });\n      }\n    }\n\n    // 関連度でソート\n    results.sort((a, b) => b.relevance - a.relevance);\n    return results;\n  }\n\n  calculateRelevance(query, kanji, data) {\n    let score = 0;\n    \n    // 完全一致\n    if (kanji === query) score += 100;\n    if (data.reading === query) score += 90;\n    if (data.romaji === query.toLowerCase()) score += 80;\n    \n    // 前方一致\n    if (kanji.startsWith(query)) score += 50;\n    if (data.reading.startsWith(query)) score += 40;\n    if (data.romaji.startsWith(query.toLowerCase())) score += 30;\n    \n    // 使用頻度\n    score += Math.min(data.frequency, 50);\n    \n    // 最近使用\n    const daysSinceUse = (Date.now() - data.lastUsed) / (1000 * 60 * 60 * 24);\n    score += Math.max(0, 30 - daysSinceUse);\n    \n    return score;\n  }\n\n  async save() {\n    const serialized = JSON.stringify(this.dictionary);\n    const size = new Blob([serialized]).size;\n    \n    if (size > this.MAX_STORAGE_SIZE) {\n      // 自動クリーンアップ：古い&低頻度の単語を削除\n      await this.cleanup();\n    }\n\n    await chrome.storage.sync.set({\n      [this.STORAGE_KEY]: this.dictionary\n    });\n\n    console.log(`Dictionary saved: ${this.dictionary.metadata.entryCount} words, ${size} bytes`);\n  }\n\n  async cleanup() {\n    const words = Object.entries(this.dictionary.words);\n    \n    // スコア計算（頻度 + 最近使用）\n    const scored = words.map(([kanji, data]) => ({\n      kanji,\n      data,\n      score: data.frequency + Math.max(0, 30 - (Date.now() - data.lastUsed) / (1000 * 60 * 60 * 24))\n    }));\n\n    // スコアでソートし、下位25%を削除\n    scored.sort((a, b) => a.score - b.score);\n    const toDelete = scored.slice(0, Math.floor(scored.length * 0.25));\n\n    toDelete.forEach(item => {\n      delete this.dictionary.words[item.kanji];\n      this.cache.delete(item.kanji);\n    });\n\n    this.dictionary.metadata.entryCount = Object.keys(this.dictionary.words).length;\n    console.log(`Cleaned up ${toDelete.length} words from dictionary`);\n  }\n\n  async exportDictionary() {\n    const exportData = {\n      ...this.dictionary,\n      exportDate: Date.now(),\n      version: chrome.runtime.getManifest().version\n    };\n\n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n      type: 'application/json'\n    });\n\n    return blob;\n  }\n\n  async importDictionary(jsonData) {\n    try {\n      const importedData = JSON.parse(jsonData);\n      \n      // バリデーション\n      if (!importedData.words || typeof importedData.words !== 'object') {\n        throw new Error('Invalid dictionary format');\n      }\n\n      // マージまたは置換\n      const choice = await this.showImportDialog(Object.keys(importedData.words).length);\n      \n      if (choice === 'replace') {\n        this.dictionary.words = importedData.words;\n      } else if (choice === 'merge') {\n        Object.assign(this.dictionary.words, importedData.words);\n      }\n\n      this.dictionary.metadata.entryCount = Object.keys(this.dictionary.words).length;\n      this.dictionary.metadata.lastUpdate = Date.now();\n      \n      this.buildCache();\n      await this.save();\n      \n      return {\n        success: true,\n        imported: Object.keys(importedData.words).length,\n        total: this.dictionary.metadata.entryCount\n      };\n    } catch (error) {\n      console.error('Import failed:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  getStatistics() {\n    const words = Object.values(this.dictionary.words);\n    const now = Date.now();\n    \n    return {\n      totalWords: words.length,\n      averageFrequency: words.reduce((sum, w) => sum + w.frequency, 0) / words.length,\n      mostUsedWord: words.reduce((max, w) => w.frequency > max.frequency ? w : max, words[0]),\n      recentlyAdded: words.filter(w => now - w.dateAdded < 7 * 24 * 60 * 60 * 1000).length,\n      storageUsage: Math.round((new Blob([JSON.stringify(this.dictionary)]).size / this.MAX_STORAGE_SIZE) * 100),\n      lastUpdate: new Date(this.dictionary.metadata.lastUpdate).toLocaleString()\n    };\n  }\n}\n\nmodule.exports = { DictionaryManager };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const { DictionaryManager } = require('./dictionary-manager.js');\n\n// Service Worker - Background処理\nclass WingdingsBackground {\n  constructor() {\n    this.dictionaryManager = new DictionaryManager();\n    this.init();\n  }\n\n  async init() {\n    await this.dictionaryManager.init();\n    this.setupContextMenus();\n    this.setupMessageHandlers();\n    this.setupTabHandlers();\n  }\n\n  setupContextMenus() {\n    chrome.contextMenus.removeAll(() => {\n      chrome.contextMenus.create({\n        id: 'wingdings-convert-page',\n        title: ' ページ全体をWingdingsに変換',\n        contexts: ['page']\n      });\n\n      chrome.contextMenus.create({\n        id: 'wingdings-revert-page', \n        title: '↩️ 元に戻す',\n        contexts: ['page']\n      });\n\n      chrome.contextMenus.create({\n        id: 'wingdings-add-word',\n        title: '➕ 選択文字を辞書に登録 \"%s\"',\n        contexts: ['selection']\n      });\n\n      chrome.contextMenus.create({\n        id: 'wingdings-show-mapping',\n        title: ' Wingdings対応表を表示',\n        contexts: ['page']\n      });\n    });\n  }\n\n  setupMessageHandlers() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      this.handleMessage(message, sender, sendResponse);\n      return true; // 非同期レスポンス用\n    });\n  }\n\n  async handleMessage(message, sender, sendResponse) {\n    try {\n      const tabId = message.tabId || sender.tab?.id;\n\n      if (!tabId) {\n        // In some cases, like the initial popup load, there's no target tab.\n        // We can ignore these messages or handle them gracefully.\n        if (message.type === 'GET_STATISTICS') {\n            const stats = this.dictionaryManager.getStatistics();\n            sendResponse({ success: true, statistics: stats });\n        }\n        return;\n      }\n\n      switch (message.type) {\n        case 'CONVERT_PAGE':\n          await this.convertPage(tabId);\n          sendResponse({ success: true });\n          break;\n\n        case 'REVERT_PAGE':\n          await this.revertPage(tabId);\n          sendResponse({ success: true });\n          break;\n\n        case 'ADD_TO_DICTIONARY':\n          const result = await this.dictionaryManager.addWord(\n            message.kanji,\n            message.reading,\n            message.romaji\n          );\n          sendResponse({ success: true, data: result });\n          break;\n\n        case 'SEARCH_DICTIONARY':\n          const searchResults = await this.dictionaryManager.searchWords(\n            message.query,\n            message.limit || 50\n          );\n          sendResponse({ success: true, results: searchResults });\n          break;\n\n        case 'REMOVE_FROM_DICTIONARY':\n          const removeResult = await this.dictionaryManager.removeWord(message.kanji);\n          sendResponse({ success: removeResult });\n          break;\n\n        case 'GET_STATISTICS':\n          const stats = this.dictionaryManager.getStatistics();\n          sendResponse({ success: true, statistics: stats });\n          break;\n\n        case 'EXPORT_DICTIONARY':\n          const blob = await this.dictionaryManager.exportDictionary();\n          const url = URL.createObjectURL(blob);\n          await chrome.downloads.download({\n            url: url,\n            filename: `wingdings-dictionary-${Date.now()}.json`,\n            saveAs: true\n          });\n          sendResponse({ success: true });\n          break;\n\n        case 'PLAY_SOUND':\n          this.playGasterSound(message.soundId);\n          sendResponse({ success: true });\n          break;\n\n        default:\n          sendResponse({ success: false, error: 'Unknown message type' });\n      }\n    } catch (error) {\n      console.error('Message handling error:', error);\n      sendResponse({ success: false, error: error.message });\n    }\n  }\n\n  setupTabHandlers() {\n    // タブ更新時の処理\n    chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n      if (changeInfo.status === 'complete' && tab.url && !tab.url.startsWith('chrome://')) {\n        try {\n          await chrome.tabs.sendMessage(tabId, {\n            type: 'PAGE_LOADED',\n            url: tab.url\n          });\n        } catch (error) {\n          // Content script が読み込まれていない場合は無視\n          console.log('Content script not ready for tab:', tabId);\n        }\n      }\n    });\n\n    // アクティブタブ変更時の処理\n    chrome.tabs.onActivated.addListener(async (activeInfo) => {\n      await this.updateBadge(activeInfo.tabId);\n    });\n  }\n\n  async convertPage(tabId) {\n    await chrome.tabs.sendMessage(tabId, {\n      type: 'CONVERT_PAGE_REQUEST'\n    });\n    \n    await this.updateBadge(tabId, 'ON');\n  }\n\n  async revertPage(tabId) {\n    await chrome.tabs.sendMessage(tabId, {\n      type: 'REVERT_PAGE_REQUEST'\n    });\n    \n    await this.updateBadge(tabId, '');\n  }\n\n  async updateBadge(tabId, text = '') {\n    await chrome.action.setBadgeText({\n      tabId: tabId,\n      text: text\n    });\n    \n    await chrome.action.setBadgeBackgroundColor({\n      tabId: tabId,\n      color: text === 'ON' ? '#4CAF50' : '#FF9800'\n    });\n  }\n\n  playGasterSound(soundId = 'gaster1') {\n    // 効果音再生（Audio APIを使用）\n    const audio = new Audio(chrome.runtime.getURL(`assets/sounds/${soundId}.mp3`));\n    audio.volume = 0.3;\n    audio.play().catch(error => {\n      console.log('Sound play failed:', error);\n    });\n  }\n}\n\n// 初期化\nconst wingdingsBackground = new WingdingsBackground();\n\n// Context Menu クリック処理\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  switch (info.menuItemId) {\n    case 'wingdings-convert-page':\n      await wingdingsBackground.convertPage(tab.id);\n      break;\n\n    case 'wingdings-revert-page':\n      await wingdingsBackground.revertPage(tab.id);\n      break;\n\n    case 'wingdings-add-word':\n      if (info.selectionText) {\n        // 選択されたテキストを辞書登録UIに送信\n        await chrome.tabs.sendMessage(tab.id, {\n          type: 'SHOW_WORD_REGISTRATION',\n          selectedText: info.selectionText.trim()\n        });\n      }\n      break;\n\n    case 'wingdings-show-mapping':\n      await chrome.tabs.create({\n        url: chrome.runtime.getURL('assets/mapping-table.html')\n      });\n      break;\n  }\n});"],"names":[],"sourceRoot":""}