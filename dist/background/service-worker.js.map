{"version":3,"file":"background/service-worker.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://wingdings-converter/./background/dictionary-manager.js","webpack://wingdings-converter/webpack/bootstrap","webpack://wingdings-converter/./background/service-worker.js"],"sourcesContent":["class DictionaryManager {\r\n  constructor() {\r\n    this.STORAGE_KEY = 'wingdings_dictionary';\r\n    this.MAX_ENTRIES = 5000;\r\n    this.MAX_STORAGE_SIZE = 95 * 1024; // 95KB (100KB制限の95%)\r\n    this.cache = new Map();\r\n  }\r\n\r\n  async init() {\r\n    const data = await chrome.storage.sync.get(this.STORAGE_KEY);\r\n    this.dictionary = data[this.STORAGE_KEY] || {\r\n      words: {},\r\n      settings: {\r\n        autoConvert: false,\r\n        showUnknownWords: true,\r\n        romajiStyle: 'hepburn'\r\n      },\r\n      metadata: {\r\n        version: '1.0',\r\n        lastUpdate: Date.now(),\r\n        entryCount: 0\r\n      }\r\n    };\r\n    \r\n    this.buildCache();\r\n  }\r\n\r\n  buildCache() {\r\n    this.cache.clear();\r\n    Object.entries(this.dictionary.words).forEach(([word, data]) => {\r\n      this.cache.set(word, data);\r\n    });\r\n  }\r\n\r\n  async addWord(kanji, reading, romaji = null) {\r\n    // 容量チェック\r\n    if (Object.keys(this.dictionary.words).length >= this.MAX_ENTRIES) {\r\n      throw new Error(`Dictionary limit reached: ${this.MAX_ENTRIES} words`);\r\n    }\r\n\r\n    // 自動ローマ字変換\r\n    if (!romaji) {\r\n      romaji = convertToRomaji(reading);\r\n    }\r\n\r\n    const wordData = {\r\n      reading: reading,\r\n      romaji: romaji,\r\n      frequency: 1,\r\n      lastUsed: Date.now(),\r\n      dateAdded: Date.now()\r\n    };\r\n\r\n    // 既存の単語は頻度更新\r\n    if (this.dictionary.words[kanji]) {\r\n      this.dictionary.words[kanji].frequency++;\r\n      this.dictionary.words[kanji].lastUsed = Date.now();\r\n    } else {\r\n      this.dictionary.words[kanji] = wordData;\r\n      this.dictionary.metadata.entryCount++;\r\n    }\r\n\r\n    this.dictionary.metadata.lastUpdate = Date.now();\r\n    this.cache.set(kanji, wordData);\r\n\r\n    await this.save();\r\n    return wordData;\r\n  }\r\n\r\n  async removeWord(kanji) {\r\n    if (this.dictionary.words[kanji]) {\r\n      delete this.dictionary.words[kanji];\r\n      this.cache.delete(kanji);\r\n      this.dictionary.metadata.entryCount--;\r\n      this.dictionary.metadata.lastUpdate = Date.now();\r\n      await this.save();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getWord(kanji) {\r\n    return this.cache.get(kanji) || null;\r\n  }\r\n\r\n  async searchWords(query, limit = 50) {\r\n    const results = [];\r\n    const queryLower = query.toLowerCase();\r\n\r\n    for (const [kanji, data] of this.cache.entries()) {\r\n      if (results.length >= limit) break;\r\n      \r\n      if (kanji.includes(query) || \r\n          data.reading.includes(query) || \r\n          data.romaji.toLowerCase().includes(queryLower)) {\r\n        results.push({\r\n          kanji: kanji,\r\n          ...data,\r\n          relevance: this.calculateRelevance(query, kanji, data)\r\n        });\r\n      }\r\n    }\r\n\r\n    // 関連度でソート\r\n    results.sort((a, b) => b.relevance - a.relevance);\r\n    return results;\r\n  }\r\n\r\n  calculateRelevance(query, kanji, data) {\r\n    let score = 0;\r\n    \r\n    // 完全一致\r\n    if (kanji === query) score += 100;\r\n    if (data.reading === query) score += 90;\r\n    if (data.romaji === query.toLowerCase()) score += 80;\r\n    \r\n    // 前方一致\r\n    if (kanji.startsWith(query)) score += 50;\r\n    if (data.reading.startsWith(query)) score += 40;\r\n    if (data.romaji.startsWith(query.toLowerCase())) score += 30;\r\n    \r\n    // 使用頻度\r\n    score += Math.min(data.frequency, 50);\r\n    \r\n    // 最近使用\r\n    const daysSinceUse = (Date.now() - data.lastUsed) / (1000 * 60 * 60 * 24);\r\n    score += Math.max(0, 30 - daysSinceUse);\r\n    \r\n    return score;\r\n  }\r\n\r\n  async save() {\r\n    const serialized = JSON.stringify(this.dictionary);\r\n    const size = new Blob([serialized]).size;\r\n    \r\n    if (size > this.MAX_STORAGE_SIZE) {\r\n      // 自動クリーンアップ：古い&低頻度の単語を削除\r\n      await this.cleanup();\r\n    }\r\n\r\n    await chrome.storage.sync.set({\r\n      [this.STORAGE_KEY]: this.dictionary\r\n    });\r\n\r\n    console.log(`Dictionary saved: ${this.dictionary.metadata.entryCount} words, ${size} bytes`);\r\n  }\r\n\r\n  async cleanup() {\r\n    const words = Object.entries(this.dictionary.words);\r\n    \r\n    // スコア計算（頻度 + 最近使用）\r\n    const scored = words.map(([kanji, data]) => ({\r\n      kanji,\r\n      data,\r\n      score: data.frequency + Math.max(0, 30 - (Date.now() - data.lastUsed) / (1000 * 60 * 60 * 24))\r\n    }));\r\n\r\n    // スコアでソートし、下位25%を削除\r\n    scored.sort((a, b) => a.score - b.score);\r\n    const toDelete = scored.slice(0, Math.floor(scored.length * 0.25));\r\n\r\n    toDelete.forEach(item => {\r\n      delete this.dictionary.words[item.kanji];\r\n      this.cache.delete(item.kanji);\r\n    });\r\n\r\n    this.dictionary.metadata.entryCount = Object.keys(this.dictionary.words).length;\r\n    console.log(`Cleaned up ${toDelete.length} words from dictionary`);\r\n  }\r\n\r\n  async exportDictionary() {\r\n    const exportData = {\r\n      ...this.dictionary,\r\n      exportDate: Date.now(),\r\n      version: chrome.runtime.getManifest().version\r\n    };\r\n\r\n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {\r\n      type: 'application/json'\r\n    });\r\n\r\n    return blob;\r\n  }\r\n\r\n  async importDictionary(jsonData) {\r\n    try {\r\n      const importedData = JSON.parse(jsonData);\r\n      \r\n      // バリデーション\r\n      if (!importedData.words || typeof importedData.words !== 'object') {\r\n        throw new Error('Invalid dictionary format');\r\n      }\r\n\r\n      // マージまたは置換\r\n      const choice = await this.showImportDialog(Object.keys(importedData.words).length);\r\n      \r\n      if (choice === 'replace') {\r\n        this.dictionary.words = importedData.words;\r\n      } else if (choice === 'merge') {\r\n        Object.assign(this.dictionary.words, importedData.words);\r\n      }\r\n\r\n      this.dictionary.metadata.entryCount = Object.keys(this.dictionary.words).length;\r\n      this.dictionary.metadata.lastUpdate = Date.now();\r\n      \r\n      this.buildCache();\r\n      await this.save();\r\n      \r\n      return {\r\n        success: true,\r\n        imported: Object.keys(importedData.words).length,\r\n        total: this.dictionary.metadata.entryCount\r\n      };\r\n    } catch (error) {\r\n      console.error('Import failed:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  getStatistics() {\r\n    const words = Object.values(this.dictionary.words);\r\n    const now = Date.now();\r\n    \r\n    return {\r\n      totalWords: words.length,\r\n      averageFrequency: words.reduce((sum, w) => sum + w.frequency, 0) / words.length,\r\n      mostUsedWord: words.reduce((max, w) => w.frequency > max.frequency ? w : max, words[0]),\r\n      recentlyAdded: words.filter(w => now - w.dateAdded < 7 * 24 * 60 * 60 * 1000).length,\r\n      storageUsage: Math.round((new Blob([JSON.stringify(this.dictionary)]).size / this.MAX_STORAGE_SIZE) * 100),\r\n      lastUpdate: new Date(this.dictionary.metadata.lastUpdate).toLocaleString()\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = { DictionaryManager };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const { DictionaryManager } = require('./dictionary-manager.js');\r\n\r\n// Service Worker - Background処理\r\nclass WingdingsBackground {\r\n  constructor() {\r\n    this.dictionaryManager = new DictionaryManager();\r\n    this.init();\r\n  }\r\n\r\n  async init() {\r\n    await this.dictionaryManager.init();\r\n    this.setupContextMenus();\r\n    this.setupMessageHandlers();\r\n    this.setupTabHandlers();\r\n  }\r\n\r\n  setupContextMenus() {\r\n    chrome.contextMenus.removeAll(() => {\r\n      chrome.contextMenus.create({\r\n        id: 'wingdings-convert-page',\r\n        title: ' ページ全体をWingdingsに変換',\r\n        contexts: ['page']\r\n      });\r\n\r\n        chrome.contextMenus.create({\r\n          id: 'REVERT_PAGE_REQUEST',\r\n          title: '↩️ 元に戻す',\r\n          contexts: ['page']\r\n        });\r\n        chrome.contextMenus.create({\r\n          id: 'CONVERT_SELECTION_FROM_WINGDINGS',\r\n          title: '選択範囲をテキストに変換',\r\n          contexts: ['selection']\r\n        });\r\n      chrome.contextMenus.create({\r\n        id: 'wingdings-add-word',\r\n        title: '➕ 選択文字を辞書に登録 \"%s\"',\r\n        contexts: ['selection']\r\n      });\r\n\r\n      chrome.contextMenus.create({\r\n        id: 'wingdings-show-mapping',\r\n        title: ' Wingdings対応表を表示',\r\n        contexts: ['page']\r\n      });\r\n    });\r\n  }\r\n\r\n  setupMessageHandlers() {\r\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n      this.handleMessage(message, sender, sendResponse);\r\n      return true; // 非同期レスポンス用\r\n    });\r\n  }\r\n\r\n  async handleMessage(message, sender, sendResponse) {\r\n    try {\r\n      const tabId = message.tabId || sender.tab?.id;\r\n\r\n      if (!tabId) {\r\n        // In some cases, like the initial popup load, there's no target tab.\r\n        // We can ignore these messages or handle them gracefully.\r\n        if (message.type === 'GET_STATISTICS') {\r\n            const stats = this.dictionaryManager.getStatistics();\r\n            sendResponse({ success: true, statistics: stats });\r\n        }\r\n        return;\r\n      }\r\n\r\n      switch (message.type) {\r\n        case 'CONVERT_PAGE':\r\n          await this.convertPage(tabId);\r\n          sendResponse({ success: true });\r\n          break;\r\n\r\n        case 'REVERT_PAGE':\r\n          await this.revertPage(tabId);\r\n          sendResponse({ success: true });\r\n          break;\r\n\r\n        case 'ADD_TO_DICTIONARY':\r\n          const result = await this.dictionaryManager.addWord(\r\n            message.kanji,\r\n            message.reading,\r\n            message.romaji\r\n          );\r\n          sendResponse({ success: true, data: result });\r\n          break;\r\n\r\n        case 'SEARCH_DICTIONARY':\r\n          const searchResults = await this.dictionaryManager.searchWords(\r\n            message.query,\r\n            message.limit || 50\r\n          );\r\n          sendResponse({ success: true, results: searchResults });\r\n          break;\r\n\r\n        case 'REMOVE_FROM_DICTIONARY':\r\n          const removeResult = await this.dictionaryManager.removeWord(message.kanji);\r\n          sendResponse({ success: removeResult });\r\n          break;\r\n\r\n        case 'GET_STATISTICS':\r\n          const stats = this.dictionaryManager.getStatistics();\r\n          sendResponse({ success: true, statistics: stats });\r\n          break;\r\n\r\n        case 'EXPORT_DICTIONARY':\r\n          const blob = await this.dictionaryManager.exportDictionary();\r\n          const url = URL.createObjectURL(blob);\r\n          await chrome.downloads.download({\r\n            url: url,\r\n            filename: `wingdings-dictionary-${Date.now()}.json`,\r\n            saveAs: true\r\n          });\r\n          sendResponse({ success: true });\r\n          break;\r\n\r\n        case 'PLAY_SOUND':\r\n          this.playGasterSound(message.soundId);\r\n          sendResponse({ success: true });\r\n          break;\r\n\r\n        default:\r\n          sendResponse({ success: false, error: 'Unknown message type' });\r\n      }\r\n    } catch (error) {\r\n      console.error('Message handling error:', error);\r\n      sendResponse({ success: false, error: error.message });\r\n    }\r\n  }\r\n\r\n  setupTabHandlers() {\r\n    // タブ更新時の処理\r\n    chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\r\n      if (changeInfo.status === 'complete' && tab.url && !tab.url.startsWith('chrome://')) {\r\n        try {\r\n          await chrome.tabs.sendMessage(tabId, {\r\n            type: 'PAGE_LOADED',\r\n            url: tab.url\r\n          });\r\n        } catch (error) {\r\n          // Content script が読み込まれていない場合は無視\r\n          console.log('Content script not ready for tab:', tabId);\r\n        }\r\n      }\r\n    });\r\n\r\n    // アクティブタブ変更時の処理\r\n    chrome.tabs.onActivated.addListener(async (activeInfo) => {\r\n      await this.updateBadge(activeInfo.tabId);\r\n    });\r\n  }\r\n\r\n  async convertPage(tabId) {\r\n    await chrome.tabs.sendMessage(tabId, {\r\n      type: 'CONVERT_PAGE_REQUEST'\r\n    });\r\n    \r\n    await this.updateBadge(tabId, 'ON');\r\n  }\r\n\r\n  async revertPage(tabId) {\r\n    await chrome.tabs.sendMessage(tabId, {\r\n      type: 'REVERT_PAGE_REQUEST'\r\n    });\r\n    \r\n    await this.updateBadge(tabId, '');\r\n  }\r\n\r\n  async updateBadge(tabId, text = '') {\r\n    await chrome.action.setBadgeText({\r\n      tabId: tabId,\r\n      text: text\r\n    });\r\n    \r\n    await chrome.action.setBadgeBackgroundColor({\r\n      tabId: tabId,\r\n      color: text === 'ON' ? '#4CAF50' : '#FF9800'\r\n    });\r\n  }\r\n\r\n  playGasterSound(soundId = 'gaster1') {\r\n    // 効果音再生（Audio APIを使用）\r\n    const audio = new Audio(chrome.runtime.getURL(`assets/sounds/${soundId}.mp3`));\r\n    audio.volume = 0.3;\r\n    audio.play().catch(error => {\r\n      console.log('Sound play failed:', error);\r\n    });\r\n  }\r\n}\r\n\r\n// 初期化\r\nconst wingdingsBackground = new WingdingsBackground();\r\n\r\n// Context Menu クリック処理\r\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\r\n  switch (info.menuItemId) {\r\n    case 'wingdings-convert-page':\r\n      await wingdingsBackground.convertPage(tab.id);\r\n      break;\r\n\r\n    case 'wingdings-revert-page':\r\n      await wingdingsBackground.revertPage(tab.id);\r\n      break;\r\n\r\n    case 'wingdings-add-word':\r\n      if (info.selectionText) {\r\n        // 選択されたテキストを辞書登録UIに送信\r\n        await chrome.tabs.sendMessage(tab.id, {\r\n          type: 'SHOW_WORD_REGISTRATION',\r\n          selectedText: info.selectionText.trim()\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'wingdings-show-mapping':\r\n      await chrome.tabs.create({\r\n        url: chrome.runtime.getURL('assets/mapping-table.html')\r\n      });\r\n      break;\r\n  }\r\n});"],"names":[],"sourceRoot":""}